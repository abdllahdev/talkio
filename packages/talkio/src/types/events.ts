/**
 * Agent Events
 *
 * Defines the event system for the voice AI agent with a two-layer architecture:
 *
 * **Public Events** (exposed via `onEvent` callback):
 * - Semantic, user-facing events that describe what's happening in the conversation
 * - Lifecycle events: `agent:started`, `agent:stopped`, `agent:error`
 * - Human turn events: `human-turn:started`, `human-turn:transcript`, `human-turn:ended`, `human-turn:abandoned`
 * - AI turn events: `ai-turn:started`, `ai-turn:token`, `ai-turn:sentence`, `ai-turn:audio`, `ai-turn:ended`, `ai-turn:interrupted`
 * - Debug events: `debug:*` for internal state visibility
 *
 * **Internal Events** (machine-only, prefixed with `_`):
 * - Low-level events used for state machine coordination
 * - Provider events: `_stt:*`, `_llm:*`, `_tts:*`, `_vad:*`
 * - Machine events: `_agent:*`, `_audio:*`, `_turn:*`
 * - Not exposed to users, used internally for state transitions
 *
 * The event system provides comprehensive observability into the agent's behavior,
 * enabling monitoring, debugging, and UI updates based on conversation state.
 *
 * @module types/events
 */

import type { AITurnMetrics, HumanTurnMetrics } from "./metrics";

/**
 * Event emitted when the agent has started and is ready to process audio.
 * All providers have been initialized and the agent is listening for input.
 */
export interface AgentStartedEvent {
  type: "agent:started";
  timestamp: number;
}

/**
 * Event emitted when the agent has stopped and all resources have been cleaned up.
 * All providers have been stopped and connections closed.
 */
export interface AgentStoppedEvent {
  type: "agent:stopped";
  timestamp: number;
}

/**
 * Event emitted when an error occurs in one of the providers.
 *
 * @property error - The error that occurred
 * @property source - Which provider encountered the error ("stt", "llm", "tts", or "vad")
 */
export interface AgentErrorEvent {
  type: "agent:error";
  error: Error;
  source: "stt" | "llm" | "tts" | "vad";
  timestamp: number;
}

/**
 * Union of all agent lifecycle events.
 * These events track the agent's overall state and lifecycle.
 */
export type AgentLifecycleEvent = AgentStartedEvent | AgentStoppedEvent | AgentErrorEvent;

/**
 * Event emitted when the user starts speaking (human turn begins).
 * Triggered by VAD or STT detecting speech activity.
 */
export interface HumanTurnStartedEvent {
  type: "human-turn:started";
  timestamp: number;
}

/**
 * Event emitted when the STT provider produces a transcript update.
 * Emitted for both partial (interim) and final transcripts.
 *
 * @property text - The transcribed text
 * @property isFinal - Whether this is a final transcript (true) or partial/interim (false)
 */
export interface HumanTurnTranscriptEvent {
  type: "human-turn:transcript";
  text: string;
  isFinal: boolean;
  timestamp: number;
}

/**
 * Event emitted when the user's turn has ended and the complete transcript is available.
 * This marks the end of the human turn and triggers the AI response.
 *
 * @property transcript - The final, complete transcript of what the user said
 * @property metrics - Metrics for this human turn (speech duration, transcript length)
 */
export interface HumanTurnEndedEvent {
  type: "human-turn:ended";
  transcript: string;
  metrics: HumanTurnMetrics;
  timestamp: number;
}

/**
 * Event emitted when a human turn is abandoned (too short, noise, etc.).
 * The turn detector determined this wasn't a valid user input.
 *
 * @property reason - Reason why the turn was abandoned (e.g., "too_short", "noise")
 */
export interface HumanTurnAbandonedEvent {
  type: "human-turn:abandoned";
  reason: string;
  timestamp: number;
}

/**
 * Union of all human turn events.
 * These events track the user's speech input and transcription.
 */
export type HumanTurnEvent =
  | HumanTurnStartedEvent
  | HumanTurnTranscriptEvent
  | HumanTurnEndedEvent
  | HumanTurnAbandonedEvent;

/**
 * Event emitted when the AI turn begins (after user turn ends).
 * The LLM provider starts generating a response.
 */
export interface AITurnStartedEvent {
  type: "ai-turn:started";
  timestamp: number;
}

/**
 * Event emitted for each token generated by the LLM provider.
 * Emitted in real-time as tokens are streamed from the LLM.
 *
 * @property token - A single token (word or subword) from the LLM
 */
export interface AITurnTokenEvent {
  type: "ai-turn:token";
  token: string;
  timestamp: number;
}

/**
 * Event emitted when a complete sentence is generated.
 * Used for sentence-level streaming to TTS for faster response times.
 *
 * @property sentence - The complete sentence text
 * @property index - Zero-based index of this sentence in the response
 */
export interface AITurnSentenceEvent {
  type: "ai-turn:sentence";
  sentence: string;
  index: number;
  timestamp: number;
}

/**
 * Event emitted when the TTS provider produces an audio chunk.
 * Audio chunks are streamed as they're synthesized for low-latency playback.
 *
 * @property audio - Raw audio bytes (ArrayBuffer) in the configured output format
 */
export interface AITurnAudioEvent {
  type: "ai-turn:audio";
  audio: ArrayBuffer;
  timestamp: number;
}

/**
 * Event emitted when the AI turn has completed successfully.
 * The full response has been generated and synthesized.
 *
 * @property text - The complete generated text
 * @property wasSpoken - Whether the text was actually spoken (true) or interrupted (false)
 * @property metrics - Metrics for this AI turn (latency, token count, duration, etc.)
 */
export interface AITurnEndedEvent {
  type: "ai-turn:ended";
  text: string;
  wasSpoken: boolean;
  metrics: AITurnMetrics;
  timestamp: number;
}

/**
 * Event emitted when the AI turn is interrupted by the user.
 * The user started speaking while the agent was responding.
 *
 * @property partialText - The text that was generated before interruption
 * @property metrics - Metrics for this interrupted turn
 */
export interface AITurnInterruptedEvent {
  type: "ai-turn:interrupted";
  partialText: string;
  metrics: AITurnMetrics;
  timestamp: number;
}

/**
 * Union of all AI turn events.
 * These events track the agent's response generation and speech synthesis.
 */
export type AITurnEvent =
  | AITurnStartedEvent
  | AITurnTokenEvent
  | AITurnSentenceEvent
  | AITurnAudioEvent
  | AITurnEndedEvent
  | AITurnInterruptedEvent;

/**
 * Event emitted by VAD providers that support probability scores.
 * Useful for visualization and debugging voice activity detection.
 *
 * @property value - Speech probability score between 0 and 1
 */
export interface VADProbabilityEvent {
  type: "vad:probability";
  value: number;
  timestamp: number;
}

/**
 * Union of all debug/observability events.
 * These events provide additional information for debugging and monitoring.
 */
export type DebugEvent = VADProbabilityEvent;

/**
 * Event emitted when silence is detected during listening.
 * Indicates the user has been silent for longer than the configured timeout.
 *
 * @property promptCount - Which prompt number this is (1-based)
 * @property maxPrompts - Maximum prompts configured
 */
export interface SilenceDetectedEvent {
  type: "silence:detected";
  promptCount: number;
  maxPrompts: number;
  timestamp: number;
}

/**
 * Union of all silence-related events.
 */
export type SilenceEvent = SilenceDetectedEvent;

export type PublicAgentEvent =
  | AgentLifecycleEvent
  | HumanTurnEvent
  | AITurnEvent
  | DebugEvent
  | SilenceEvent;

export interface InternalAudioInputEvent {
  type: "_audio:input";
  audio: ArrayBuffer;
  timestamp: number;
}

export interface InternalSTTTranscriptEvent {
  type: "_stt:transcript";
  text: string;
  isFinal: boolean;
  timestamp: number;
}

export interface InternalSTTSpeechStartEvent {
  type: "_stt:speech-start";
  timestamp: number;
}

export interface InternalSTTSpeechEndEvent {
  type: "_stt:speech-end";
  timestamp: number;
}

export interface InternalSTTErrorEvent {
  type: "_stt:error";
  error: Error;
  timestamp: number;
}

export type InternalSTTEvent =
  | InternalSTTTranscriptEvent
  | InternalSTTSpeechStartEvent
  | InternalSTTSpeechEndEvent
  | InternalSTTErrorEvent;

export interface InternalVADSpeechStartEvent {
  type: "_vad:speech-start";
  timestamp: number;
}

export interface InternalVADSpeechEndEvent {
  type: "_vad:speech-end";
  duration: number;
  timestamp: number;
}

export interface InternalVADProbabilityEvent {
  type: "_vad:probability";
  value: number;
  timestamp: number;
}

export type InternalVADEvent =
  | InternalVADSpeechStartEvent
  | InternalVADSpeechEndEvent
  | InternalVADProbabilityEvent;

export interface InternalTurnEndEvent {
  type: "_turn:end";
  transcript: string;
  timestamp: number;
}

export interface InternalTurnAbandonedEvent {
  type: "_turn:abandoned";
  reason: string;
  timestamp: number;
}

export type InternalTurnDetectorEvent = InternalTurnEndEvent | InternalTurnAbandonedEvent;

export interface InternalLLMTokenEvent {
  type: "_llm:token";
  token: string;
  timestamp: number;
}

export interface InternalLLMSentenceEvent {
  type: "_llm:sentence";
  sentence: string;
  index: number;
  timestamp: number;
}

export interface InternalLLMCompleteEvent {
  type: "_llm:complete";
  fullText: string;
  timestamp: number;
}

export interface InternalLLMErrorEvent {
  type: "_llm:error";
  error: Error;
  timestamp: number;
}

export type InternalLLMEvent =
  | InternalLLMTokenEvent
  | InternalLLMSentenceEvent
  | InternalLLMCompleteEvent
  | InternalLLMErrorEvent;

export interface InternalTTSChunkEvent {
  type: "_tts:chunk";
  audio: ArrayBuffer;
  timestamp: number;
}

export interface InternalTTSCompleteEvent {
  type: "_tts:complete";
  timestamp: number;
}

export interface InternalTTSErrorEvent {
  type: "_tts:error";
  error: Error;
  timestamp: number;
}

export type InternalTTSEvent =
  | InternalTTSChunkEvent
  | InternalTTSCompleteEvent
  | InternalTTSErrorEvent;

export interface InternalFillerSayEvent {
  type: "_filler:say";
  text: string;
  timestamp: number;
}

export interface InternalFillerInterruptEvent {
  type: "_filler:interrupt";
  timestamp: number;
}

export type InternalFillerEvent = InternalFillerSayEvent | InternalFillerInterruptEvent;

export interface InternalAudioOutputStartEvent {
  type: "_audio:output-start";
  timestamp: number;
}

export interface InternalAudioOutputChunkEvent {
  type: "_audio:output-chunk";
  audio: ArrayBuffer;
  timestamp: number;
}

export interface InternalAudioOutputEndEvent {
  type: "_audio:output-end";
  timestamp: number;
}

export interface InternalAudioOutputErrorEvent {
  type: "_audio:output-error";
  error: Error;
  timestamp: number;
}

export type InternalAudioOutputEvent =
  | InternalAudioOutputStartEvent
  | InternalAudioOutputChunkEvent
  | InternalAudioOutputEndEvent
  | InternalAudioOutputErrorEvent;

export interface InternalAgentStartEvent {
  type: "_agent:start";
  timestamp: number;
}

export interface InternalAgentStopEvent {
  type: "_agent:stop";
  timestamp: number;
}

export type InternalAgentControlEvent = InternalAgentStartEvent | InternalAgentStopEvent;

export interface InternalSilenceTimeoutEvent {
  type: "_silence:timeout";
  timestamp: number;
}

export type InternalSilenceEvent = InternalSilenceTimeoutEvent;

export type InternalAgentEvent =
  | InternalAudioInputEvent
  | InternalSTTEvent
  | InternalVADEvent
  | InternalTurnDetectorEvent
  | InternalLLMEvent
  | InternalTTSEvent
  | InternalFillerEvent
  | InternalAudioOutputEvent
  | InternalAgentControlEvent
  | InternalSilenceEvent;

export type MachineEvent = PublicAgentEvent | InternalAgentEvent;

/**
 * User-facing agent event type.
 *
 * This is the union of all public events that are exposed via the `onEvent` callback.
 * Internal events (prefixed with "_") are filtered out and not exposed to users.
 *
 * Use this type to type your event handler:
 *
 * @example
 * ```typescript
 * const agent = createAgent({
 *   stt, llm, tts,
 *   onEvent: (event: AgentEvent) => {
 *     switch (event.type) {
 *       case "human-turn:ended":
 *         console.log("User:", event.transcript);
 *         break;
 *       case "ai-turn:sentence":
 *         console.log("Agent:", event.sentence);
 *         break;
 *     }
 *   },
 * });
 * ```
 */
export type AgentEvent = PublicAgentEvent;
